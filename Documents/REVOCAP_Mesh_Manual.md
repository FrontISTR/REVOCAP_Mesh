# 要素ライブラリ

REVOCAP_PrePost のメッシュ処理部で内部データとして保持することのできる要素の一覧である。
この節点配列の順番で要素の登録、要素データの取得が行われる。
以下の記述で節点配列や接続行列の添え字は0から始まる。
接続行列はi番目の節点とj番目の節点の接続情報を表している。
ただし利用者が直接この行列を利用することはない。
1次要素とみなしてつながっているときは±1とし、2次要素とみなしてつながっているときは±2とする。
符号は向きを表し、線要素、平面要素のみ有効である。
辺、面情報は内部で保持している辺や面の順番を記述してある。
各行は立体要素の場合はその面、平面要素の場合はその辺の節点の接続情報が記述されている。
（4面体要素なら、それぞれの行が三角形要素の節点IDの配列）面は外から見て反時計回りが正となるように向き付けられている。

## 線分1次要素(SEGMENT)

接続行列
||0|1|
|-|-|-|
|0|0|1|
|1|-1|0|
 
![SEGMENT](images/segment.gif "線分要素")

## 線分2次要素 (SEGMENT2)

接続行列

||0|1|2|
|-|-|-|-|
|0|0|1|2|
|1|-1|0|-2|
|2|-2|2|0|
 
![SEGMENT2](images/segment2.gif "線分2次要素")

## 三角形1次要素 (TRIANGLE)

接続行列

||0|1|2|
|-|-|-|-|
|0|0|1|-1|
|1|-1|0|1|
|2|1|-1|0|

辺

||0|1|
|-|-|-|
|0|1|2|
|1|2|0|
|2|0|1|
 
![TRIANGLE](images/triangle.gif "三角形1次要素")

## 三角形2次要素 (TRIANGLE2)

接続行列

||0|1|2|3|4|5|
|-|-|-|-|-|-|-|
|0|0|1|-1|0|-2|2|
|1|-1|0|1|2|0|-2|
|2|1|-1|0|-2|2|0|
|3|0|-2|2|0|0|0|
|4|2|0|-2|0|0|0|
|5|-2|2|0|0|0|0|

辺

||0|1|2|
|-|-|-|-|
|0|1|2|3|
|0|2|0|4|
|0|0|1|5|
 
![TRIANGLE2](images/triangle2.gif "三角形2次要素")

## 四角形1次要素 (QUAD)

接続行列

~~~
0	1	0	-1
-1	0	1	0
0	-1	0	1
1	0	-1	0
~~~

辺

~~~
0	1
1	2
2	3
3	0
~~~

![QUAD](images/quad.gif "四角形1次要素")

## 四角形2次要素 (QUAD2)

接続行列

~~~
0	1	0	-1	2	0	0	-2
-1	0	1	0	-2	2	0	0
0	-1	0	1	0	-2	2	0
1	0	-1	0	0	0	-2	2
-2	2	0	0	0	0	0	0
0	-2	2	0	0	0	0	0
0	0	-2	2	0	0	0	0
2	0	0	-2	0	0	0	0
~~~

辺

~~~
0	1	4
1	2	5
2	3	6
3	0	7
~~~

![QUAD2](images/quad2.gif "四角形2次要素")

## 四面体1次要素 (TETRAHEDRON)

接続行列

~~~
0	1	1	1
1	0	1	1
1	1	0	1
1	1	1	0
~~~

面

~~~
1	2	3
0	3	2
0	1	3
0	2	1
~~~

![TETRAHEDRON](images/tetrahedron.gif "四面体1次要素")

## 四面体2次要素 (TETRAHEDRON2)

接続行列

~~~
0	1	1	1	0	2	2	2	0	0
1	0	1	1	2	0	2	0	2	0
1	1	0	1	2	2	0	0	0	2
1	1	1	0	0	0	0	2	2	2
0	2	2	0	0	0	0	0	0	0
2	0	2	0	0	0	0	0	0	0
2	2	0	0	0	0	0	0	0	0
2	0	0	2	0	0	0	0	0	0
0	2	0	2	0	0	0	0	0	0
0	0	2	2	0	0	0	0	0	0
~~~

面情報

~~~
1	2	3	9	8	4
0	3	2	9	5	7
0	1	3	8	7	6
0	2	1	4	6	5
~~~

![TETRAHEDRON2](images/tetrahedron2.gif "四面体2次要素")

## 六面体1次要素 (HEXAHEDRON)

接続行列

~~~
0	1	0	1	1	0	0	0
1	0	1	0	0	1	0	0
0	1	0	1	0	0	1	0
1	0	1	0	0	0	0	1
1	0	0	0	0	1	0	1
0	1	0	0	1	0	1	0
0	0	1	0	0	1	0	1
0	0	0	1	1	0	1	0
~~~

面

~~~
3	2	1	0
4	5	6	7
1	5	4	0
1	2	6	5
3	7	6	2
4	7	3	0
~~~

![HEXAHEDRON](images/hexahedron.gif "六面体1次要素")

## 六面体2次要素 (HEXAHEDRON2)

接続行列

~~~
0	1	0	1	1	0	0	0	2	0	0	2	0	0	0	0	2	0	0	0
1	0	1	0	0	1	0	0	2	2	0	0	0	0	0	0	0	2	0	0
0	1	0	1	0	0	1	0	0	2	2	0	0	0	0	0	0	0	2	0
1	0	1	0	0	0	0	1	0	0	2	2	0	0	0	0	0	0	0	2
1	0	0	0	0	1	0	1	0	0	0	0	2	0	0	2	2	0	0	0
0	1	0	0	1	0	1	0	0	0	0	0	2	2	0	0	0	2	0	0
0	0	1	0	0	1	0	1	0	0	0	0	0	2	2	0	0	0	2	0
0	0	0	1	1	0	1	0	0	0	0	0	0	0	2	2	0	0	0	2
2	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	2	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	2	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
2	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	0	2	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	0	0	2	2	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	0	0	0	2	2	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	0	2	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0
2	0	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	2	0	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	2	0	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	2	0	0	0	2	0	0	0	0	0	0	0	0	0	0	0	0
~~~

面

~~~
3	2	1	0	10	9	8	11
4	5	6	7	12	13	14	15
1	5	4	0	17	12	16	8
1	2	6	5	9	18	13	17
3	7	6	2	19	14	18	10
4	7	3	0	15	19	11	16
~~~

![HEXAHEDRON2](images/hexahedron2.gif "六面体2次要素")

## 三角柱1次要素 (WEDGE)

接続行列

~~~
0	1	1	1	0	0
1	0	1	0	1	0
1	1	0	0	0	1
1	0	0	0	1	1
0	1	0	1	0	1
0	0	1	1	1	0
~~~

面情報

~~~
0	2	1	
3	4	5	
0	1	4	3
1	2	5	4
2	0	3	5
~~~

![WEDGE](images/wedge.gif "三角柱1次要素")

## 三角柱2次要素 (WEDGE2)

接続行列

~~~
0	1	1	1	0	0	0	2	2	0	0	0	2	0	0
1	0	1	0	1	0	2	0	2	0	0	0	0	2	0
1	1	0	0	0	1	2	2	0	0	0	0	0	0	2
1	0	0	0	1	1	0	0	0	0	2	2	2	0	0
0	1	0	1	0	1	0	0	0	2	0	2	0	2	0
0	0	1	1	1	0	0	0	0	2	2	0	0	0	2
0	2	2	0	0	0	0	0	0	0	0	0	0	0	0
2	0	2	0	0	0	0	0	0	0	0	0	0	0	0
2	2	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	0	2	2	0	0	0	0	0	0	0	0	0
0	0	0	2	0	2	0	0	0	0	0	0	0	0	0
0	0	0	2	2	0	0	0	0	0	0	0	0	0	0
2	0	0	2	0	0	0	0	0	0	0	0	0	0	0
0	2	0	0	2	0	0	0	0	0	0	0	0	0	0
0	0	2	0	0	2	0	0	0	0	0	0	0	0	0
~~~

面情報

~~~
0	2	1	6	8	7		
3	4	5	9	10	11		
0	1	4	3	8	13	11	12
1	2	5	4	6	14	9	13
2	0	3	5	7	12	10	14
~~~

![WEDGE2](images/wedge2.gif "三角柱2次要素")

## 四角錐1次要素 (PYRAMID)

接続行列

~~~
0	1	1	1	1
1	0	1	0	1
1	1	0	1	0
1	0	1	0	1
1	1	0	1	0
~~~

面

~~~
0	1	2	
0	2	3	
0	3	4	
0	4	1	
4	3	2	1
~~~

![PYRAMID](images/pyramid.gif "四角錐1次要素")

## 四角錐2次要素 (PYRAMID2)

接続行列

~~~
0	1	1	1	1	2	2	2	2	0	0	0	0
1	0	1	0	1	2	0	0	0	2	0	0	2
1	1	0	1	0	0	2	0	0	2	2	0	0
1	0	1	0	1	0	0	2	0	0	2	2	0
1	1	0	1	0	0	0	0	2	0	0	2	2
2	2	0	0	0	0	0	0	0	0	0	0	0
2	0	2	0	0	0	0	0	0	0	0	0	0
2	0	0	2	0	0	0	0	0	0	0	0	0
2	0	0	0	2	0	0	0	0	0	0	0	0
0	2	2	0	0	0	0	0	0	0	0	0	0
0	0	2	2	0	0	0	0	0	0	0	0	0
0	0	0	2	2	0	0	0	0	0	0	0	0
0	2	0	0	2	0	0	0	0	0	0	0	0
~~~

面

~~~
0	1	2	9	6	5		
0	2	3	10	7	6		
0	3	4	11	8	7		
0	4	1	12	5	8		
4	3	2	1	11	10	9	12
~~~

![PYRAMID2](images/pyramid2.gif "四角錐2次要素")

# メッシュ処理拡張ライブラリの利用方法

REVOCAP_PrePostの内部でのメッシュ処理はC++言語で実装された拡張ライブラリを用いている。
ユーザーがRuby言語でスクリプトを作成する場合に、REVOCAP_PrePostのメッシュ処理モジュールを利用する方法を述べる。
メッシュ処理モジュールは次の5つの拡張ライブラリからなる。

- RevocapMesh：メッシュデータ格納および基本的な幾何処理
- RevocapMeshGen：メッシュ生成ルーチン
- RevocapIO：メッシュデータ入出力
- RevocapGL：メッシュデータをOpenGLで描画するための処理
- RevocapShape：OpenCASCADEおよび曲面の形状処理

これらをRuby言語から使うには、拡張ライブラリのパスが設定されている場所にこれらの拡張ライブラリをコピーし、require文で読み込めばよい。
ファイル名と同じ名前でRuby言語のModuleが定義されているので、例えばMeshDBクラスのインスタンスを生成する場合はRevocapMesh::MeshDB.newとする必要があることに注意する（include文でModule名を省略できるように指定してもよい）。

# 使用例

ここではREVOCAP_PrePostの内部で用いられているメッシュ処理モジュールをスクリプト言語から利用する例について説明する。

## メッシュデータの読み書き

メッシュデータ格納ライブラリと入出力ルーチンを組み合わせると、メッシュフォーマットの変換を行うことができる。

~~~ruby
require 'RevocapMesh'
require 'RevocapIO'

mesh = RevocapMesh::MeshDB.new
reader = RevocapIO::MicroAVSIO.new
writer = RevocapIO::TetMeshMshIO.new
reader.loadFromFile(ARGV[0],mesh)
writer.saveToFile(ARGV[1],mesh)
~~~

この例はコマンドライン引数の1番目にMicroAVS形式のメッシュファイル名を与えて、
2番目に与えられたファイル名でADVENTURE_TetMesh形式のファイルを出力するものである。
ただし、物理量および四面体要素以外は出力しない。

## 自分で入出力ルーチンを書くには

内製ソルバーの出力データなどを入力として用いるためには、読み込み用の入力ルーチンをスクリプトにしておくとよい。
メッシュデータ格納用のクラスRevocapMesh::MeshDBのインスタンスに対して、節点、要素と物理量の入出力の方法を説明する。

### 節点データの入力

節点データを入力するには、addNode メソッドを使う。

~~~ruby
mesh.beginNode(100)             # 節点の登録開始（節点数の予約）
mesh.addNode(0.0, 2.0, -3.0)    # (0.0,2.0,-3.0) の点を追加
.....
mesh.endNode                    # 節点の登録終了
~~~

### 節点データの出力

節点データはイテレータを使って取り出すことが出来ます。

~~~ruby
# 配列で頂点の座標を取り出す
mesh.eachNode{ |n|
  puts "x=#{n[0]} , y=#{n[1]}, z=#{n[2]}"
}
~~~

### 要素データの入力

要素データを入力するにはaddElementメソッドを使います。beginElementメソッドとendElementメソッドの間で実行されたaddElementメソッドで与えられた要素は1つのグループにまとめられて、内部ではBodyとして管理される。材料属性を与える場合や、イテレータで出力する場合もBodyを単位とする。

~~~ruby
mesh.beginElement(100)   # 要素の登録開始
mesh.addElement(“TETRAHEDRON”,[0,1,2,3])
.....
mesh.endElement
~~~

addElementは最初の引数で要素の型を表す文字列を受け取る。2番目の引数で節点配列を受け取る。節点配列の幾何的な順番はマニュアルを参照のこと。

### 要素データの出力

要素をグループとしてまとめてBodyとして管理されている。
それぞれのBodyは整数値の識別番号を持つ。要素データを出力するときは、識別番号を与えてイテレータを使って取り出す。

~~~ruby
# 型と節点番号の配列
mesh.eachElement(bodyId){ |element|
  type = element.shift
  puts "type = #{type}, array = #{element.inspect}"
}
~~~

要素番号もいっしょに取り出す場合は以下のようにする。

~~~
mesh.eachElementWithId(bodyId){ |element,id|
  puts "id = #{id}, #{element.inspect}"
}
~~~

### 節点および要素への物理データの登録と取り出し

RevocapMesh::MeshDBクラスは、境界条件や計算結果の物理量などのデータを
節点番号や要素番号と対応させて扱うためのデータ構造を内部に持つ。
文字列をキーにしてデータを管理しているため、あらかじめ構造体などを定義しておく必要がなく、任意の名前の境界条件や物理量を格納することができる。
例えば要素番号ElementID = 1,2,3の要素それぞれにスカラー値の物理量 "hoge" を与えるには、以下のようにする。

~~~ruby
mesh.createData("hoge","ELEMENTVARIABLE","SCALAR")
mesh.setPhysicalValueAtId("hoge", 0, 0.0)
mesh.setPhysicalValueAtId("hoge", 1, 1.0)
mesh.setPhysicalValueAtId("hoge", 2, 0.0)
~~~

Bodyで格納されている面全体の頂点すべてにスカラー値を与えるには、以下のようにする。

~~~ruby
mesh.createData("hoge","NODEVARIABLE","SCALAR")
mesh.eachNodeInBodyWithId(bodyId){ |node,id|
  mesh.setPhysicalValueAtId("hoge", id, 0.1)
}
~~~

節点の集合全体に一定値を与える場合は、

~~~ruby
mesh.createData("hoge","NODEGROUP","SCALAR")
mesh.eachNodeInBodyWithId(bodyId){ |node,id|
  mesh.addId("hoge", id)
}
mesh.setPhysicalValue("hoge", 0.1)
~~~

とする。要素グループ全体に定数値を与えるには

~~~ruby
mesh.createData("hoge","BODYGROUP","SCALAR")
mesh.addId("hoge", bodyId)
mesh.setPhysicalValue("hoge", 0.1)
~~~

のようにする。どのデータ構造で値を格納するかはプリ処理のユーザインターフェースや解析ソルバの要求に従って選択する。

## 表面抽出と分割

ソリッド要素のみからなる要素グループ(Body)から表面を抽出し、さらにその表面のある角度を閾値として表面を分割することができる。

~~~ruby
bodyId = 0       # 対象となる Body
angle = 120.0    # 分割角度閾値
boun = RevocapMesh::BoundaryExtractor.new
boun.setMesh(mesh)
boun.appnedBody(bodyId)
surface = boun.getBoundary(bodyId)
divider = RevocapMesh::SurfaceOperation.new
divider.setMesh(mesh)
surfaces = divider.divideSurfaceWithRidge(surface,angle)
~~~

surfacesは分割された表面のbodyIdのArrayになっている。
