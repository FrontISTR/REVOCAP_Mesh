#pragma once

#include "RevocapIO/kmbStereolithographyIO.h"
#include "Geometry/kmbIdTypes.h"
#include "MeshDB/kmbElement.h"

#include <fstream>
#include <sstream>
#include <iostream>

template<typename MContainer>
int kmb::StereolithographyIO::loadPatch(std::string filename, MContainer* patch)
{
	switch( checkFormat(filename) )
	{
	case kmb::StereolithographyIO::kBINARY:
		return loadBinaryPatch(filename,patch);
	case kmb::StereolithographyIO::kASCII:
		return loadAsciiPatch(filename,patch);
	default:
		break;
	}
	return -1;
}

template<typename MContainer>
int kmb::StereolithographyIO::loadBinaryPatch(std::string filename, MContainer* patch)
{
	std::cout << "StereolithographyIO loadBinaryPatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ifstream input(filename.c_str(), std::ios_base::in | std::ios_base::binary);
	if (input.fail()) {
		std::cout << "Load Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	input.seekg(0, std::ios::beg);
	char buf[80];
	input.read(buf, 80);
	std::cout << "header = " << buf << std::endl;
	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	int size = 0;
	float v[3] = { 0.0,0.0,0.0 };
	short attr;
	input.read(reinterpret_cast<char*>(&size), sizeof(int));
	std::cout << "size = " << size << std::endl;
	patch->beginNode(3 * size);
	patch->beginElement(size);
	for (int i = 0; i<size; ++i) {
		// normal
		input.read(reinterpret_cast<char*>(v), 3 * sizeof(float));
		for (int j = 0; j<3; ++j) {
			// vertex
			input.read(reinterpret_cast<char*>(v), 3 * sizeof(float));
			patch->addNode(
				static_cast<double>(v[0]),
				static_cast<double>(v[1]),
				static_cast<double>(v[2]));
			nodes[j] = 3 * i + j;
		}
		// attribute
		input.read(reinterpret_cast<char*>(&attr), sizeof(short));
		patch->addElement(kmb::kTriangle, nodes);
	}
	patch->endElement();
	patch->endNode();
	input.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::loadAsciiPatch(std::string filename, MContainer* patch)
{
	std::cout << "StereolithographyIO loadAsciiPatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ifstream input(filename.c_str(), std::ios_base::in );
	if (input.fail()) {
		std::cout << "Load Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	input.seekg(0, std::ios::beg);
	std::string str,tag,name;
	int index = 0;
	double x,y,z,dist;
	kmb::bodyIdType bodyId;
	kmb::nodeIdType nodes[3] = {kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId};
	patch->beginNode();
	while( std::getline( input, str ) ){
		if( str.find("endsolid") != std::string::npos ){
			patch->endElement();
			std::stringstream is(str);
			is >> tag >> name;
			patch->setBodyName(bodyId,name.c_str());
		}else if( str.find("solid") != std::string::npos ){
			bodyId = patch->beginElement();
		}else if( str.find("vertex") != std::string::npos && index < 3 ){
			std::stringstream is(str);
			is >> tag >> x >> y >> z;
			nodes[index] = patch->addNode(x,y,z);
			++index;
		}else if( str.find("endfacet") != std::string::npos ){
			patch->addElement( kmb::TRIANGLE, nodes );
		}else if( str.find("facet") != std::string::npos ){
			index = 0;
		}
	}
	patch->endNode();
	input.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::savePatch(std::string filename, const MContainer* patch, kmb::bodyIdType bodyId)
{
	std::cout << "StereolithographyIO savePatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ofstream output(filename.c_str(), std::ios_base::out | std::ios_base::binary);
	if (output.fail()) {
		std::cout << "Save Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	std::string name = patch->getBodyName(bodyId);
	std::string title = "Generated by REVOCAP : " + name;
	char buf[81];
	sprintf(buf,"%-80s", title.c_str());
	output.write(buf, 80);
	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	int size = patch->getElementCountByType(bodyId,kmb::kTriangle);
	output.write(reinterpret_cast<char*>(&size), sizeof(int));

	buf[0] = static_cast<char>(0);
	buf[1] = static_cast<char>(0);
	float f[3];
	kmb::Point3D p0, p1, p2;
	kmb::Vector3D normal;
	typename MContainer::elementIterator eIter = patch->beginElementIterator(bodyId);
	typename MContainer::elementIterator eIterEnd = patch->endElementIterator(bodyId);
	while( eIter != eIterEnd ){
		if( eIter.getType() == kmb::kTriangle ){
			kmb::elementIdType e0 = eIter[0];
			kmb::elementIdType e1 = eIter[1];
			kmb::elementIdType e2 = eIter[2];
			patch->getNode(e0,p0);
			patch->getNode(e1,p1);
			patch->getNode(e2,p2);
			normal = kmb::Point3D::calcNormalVector(p0,p1,p2);
			f[0] = static_cast<float>(normal.x());
			f[1] = static_cast<float>(normal.y());
			f[2] = static_cast<float>(normal.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p0.x());
			f[1] = static_cast<float>(p0.y());
			f[2] = static_cast<float>(p0.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p1.x());
			f[1] = static_cast<float>(p1.y());
			f[2] = static_cast<float>(p1.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p2.x());
			f[1] = static_cast<float>(p2.y());
			f[2] = static_cast<float>(p2.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			output.write(buf,2);
		}
		++eIter;
	}
	output.close();
	return 0;
}
