#pragma once

#include "RevocapIO/kmbStereolithographyIO.h"
#include "Geometry/kmbIdTypes.h"
#include "MeshDB/kmbElement.h"

#include <fstream>
#include <sstream>
#include <iostream>

#ifdef _WIN32
#if _MSC_VER >= 1400
#define sprintf sprintf_s
#endif
#endif

template<typename MContainer>
int kmb::StereolithographyIO::loadPatch(std::string filename, MContainer* patch)
{
	switch( checkFormat(filename) )
	{
	case kmb::StereolithographyIO::kBINARY:
		return loadBinaryPatch(filename,patch);
	case kmb::StereolithographyIO::kASCII:
		return loadAsciiPatch(filename,patch);
	default:
		break;
	}
	return -1;
}

template<typename MContainer>
int kmb::StereolithographyIO::loadBinaryPatch(std::string filename, MContainer* patch)
{
	std::cout << "StereolithographyIO loadBinaryPatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ifstream input(filename.c_str(), std::ios_base::in | std::ios_base::binary);
	if (input.fail()) {
		std::cout << "Load Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	input.seekg(0, std::ios::beg);
	char buf[80];
	input.read(buf, 80);
	std::cout << "header = " << buf << std::endl;
	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	int size = 0;
	float v[3] = { 0.0,0.0,0.0 };
	short attr;
	input.read(reinterpret_cast<char*>(&size), sizeof(int));
	std::cout << "size = " << size << std::endl;
	patch->beginNode(3 * size);
	patch->beginElement(size);
	for (int i = 0; i<size; ++i) {
		// normal
		input.read(reinterpret_cast<char*>(v), 3 * sizeof(float));
		for (int j = 0; j<3; ++j) {
			// vertex
			input.read(reinterpret_cast<char*>(v), 3 * sizeof(float));
			patch->addNode(
				static_cast<double>(v[0]),
				static_cast<double>(v[1]),
				static_cast<double>(v[2]));
			nodes[j] = 3 * i + j;
		}
		// attribute
		input.read(reinterpret_cast<char*>(&attr), sizeof(short));
		patch->addElement(kmb::kTriangle, nodes);
	}
	patch->endElement();
	patch->endNode();
	input.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::loadAsciiPatch(std::string filename, MContainer* patch)
{
	std::cout << "StereolithographyIO loadAsciiPatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::vector<int> facet_sizes;
	int size = countFacet(filename,facet_sizes);
	std::ifstream input(filename.c_str(), std::ios_base::in );
	if (input.fail()) {
		std::cout << "Load Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	input.seekg(0, std::ios::beg);
	std::string str,tag,name;
	int index = 0;
	int region_index = 0;
	double x,y,z;
	kmb::bodyIdType bodyId;
	kmb::nodeIdType nodes[3] = {kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId};
	patch->beginNode(3*size);
	while( std::getline( input, str ) ){
		if( str.find("endsolid") != std::string::npos ){
			patch->endElement();
			std::stringstream is(str);
			is >> tag >> name;
			patch->setBodyName(bodyId,name.c_str());
			region_index++;
		}else if( str.find("solid") != std::string::npos ){
			bodyId = patch->beginElement(facet_sizes[region_index]);
		}else if( str.find("vertex") != std::string::npos && index < 3 ){
			std::stringstream is(str);
			is >> tag >> x >> y >> z;
			nodes[index] = patch->addNode(x,y,z);
			++index;
		}else if( str.find("endfacet") != std::string::npos ){
			patch->addElement( kmb::TRIANGLE, nodes );
		}else if( str.find("facet") != std::string::npos ){
			index = 0;
		}
	}
	patch->endNode();
	input.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::savePatch(std::string filename, const MContainer* patch, kmb::bodyIdType bodyId)
{
	std::cout << "StereolithographyIO savePatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ofstream output(filename.c_str(), std::ios_base::out | std::ios_base::binary);
	if (output.fail()) {
		std::cout << "Save Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	std::string name = patch->getBodyName(bodyId);
	std::string title = "Generated by REVOCAP : " + name;
	char buf[81];
	sprintf(buf,"%-80s", title.c_str());
	output.write(buf, 80);
	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	int size = static_cast<int>(patch->getElementCountByType(bodyId,kmb::kTriangle));
	output.write(reinterpret_cast<char*>(&size), sizeof(int));

	buf[0] = static_cast<char>(0);
	buf[1] = static_cast<char>(0);
	float f[3];
	kmb::Point3D p0, p1, p2;
	kmb::Vector3D normal;
	typename MContainer::elementIterator eIter = patch->beginElementIterator(bodyId);
	typename MContainer::elementIterator eIterEnd = patch->endElementIterator(bodyId);
	while( eIter != eIterEnd ){
		if( eIter.getType() == kmb::kTriangle ){
			kmb::elementIdType e0 = eIter[0];
			kmb::elementIdType e1 = eIter[1];
			kmb::elementIdType e2 = eIter[2];
			patch->getNode(e0,p0);
			patch->getNode(e1,p1);
			patch->getNode(e2,p2);
			normal = kmb::Point3D::calcNormalVector(p0,p1,p2);
			f[0] = static_cast<float>(normal.x());
			f[1] = static_cast<float>(normal.y());
			f[2] = static_cast<float>(normal.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p0.x());
			f[1] = static_cast<float>(p0.y());
			f[2] = static_cast<float>(p0.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p1.x());
			f[1] = static_cast<float>(p1.y());
			f[2] = static_cast<float>(p1.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			f[0] = static_cast<float>(p2.x());
			f[1] = static_cast<float>(p2.y());
			f[2] = static_cast<float>(p2.z());
			output.write(reinterpret_cast<char*>(f),3*sizeof(float));
			output.write(buf,2);
		}
		++eIter;
	}
	output.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::saveAsciiPatch(std::string filename, const MContainer* patch)
{
	std::cout << "StereolithographyIO saveAsciiPatch" << std::endl;
	if (patch == NULL) {
		return -1;
	}
	std::ofstream output(filename.c_str(), std::ios_base::out);
	if (output.fail()) {
		std::cout << "Save Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	kmb::bodyIdType bodyCount = static_cast<kmb::bodyIdType>(patch->getBodyCount());
	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	kmb::Point3D p0, p1, p2;
	kmb::Vector3D normal;
	for (kmb::bodyIdType bodyId = 0; bodyId < bodyCount; ++bodyId) {
		std::string name = patch->getBodyName(bodyId);
		if (name.size() == 0) {
			name = "patch_" + std::to_string(bodyId);
		}
		output << "solid " << name << std::endl;
		typename MContainer::elementIterator eIter = patch->beginElementIterator(bodyId);
		typename MContainer::elementIterator eIterEnd = patch->endElementIterator(bodyId);
		while (eIter != eIterEnd) {
			if (eIter.getType() == kmb::kTriangle) {
				kmb::elementIdType e0 = eIter[0];
				kmb::elementIdType e1 = eIter[1];
				kmb::elementIdType e2 = eIter[2];
				patch->getNode(e0, p0);
				patch->getNode(e1, p1);
				patch->getNode(e2, p2);
				normal = kmb::Point3D::calcNormalVector(p0, p1, p2);
				output << "  facet normal " << normal.x() << " " << normal.y() << " " << normal.z() << std::endl;
				output << "    outer loop" << std::endl;
				output << "     vertex " << p0.x() << " " << p0.y() << " " << p0.z() << std::endl;
				output << "     vertex " << p1.x() << " " << p1.y() << " " << p1.z() << std::endl;
				output << "     vertex " << p2.x() << " " << p2.y() << " " << p2.z() << std::endl;
				output << "    endloop" << std::endl;
				output << "  endfacet" << std::endl;
			}
			++eIter;
		}
		output << "endsolid " << name << std::endl;
	}
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::savePatchBrep(std::string filename, kmb::PatchBrep<MContainer> &brep)
{
	std::cout << "StereolithographyIO savePatchBrep" << std::endl;
	std::ofstream output(filename.c_str(), std::ios_base::out | std::ios_base::binary);
	if (output.fail()) {
		std::cout << "Save Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	std::string title = "Generated by REVOCAP";
	char buf[81];
	sprintf(buf, "%-80s", title.c_str());
	output.write(buf, 80);

	kmb::nodeIdType nodes[3] = { kmb::nullNodeId,kmb::nullNodeId,kmb::nullNodeId };
	buf[0] = static_cast<char>(0);
	buf[1] = static_cast<char>(0);
	float f[3];
	kmb::Point3D p0, p1, p2;
	kmb::Vector3D normal;

	int shellCount = brep.getShellCount();
	for (int i = 0; i < shellCount; ++i) {
		int shell = static_cast<int>(brep.getShell(i));
		int surfaceCount = brep.getSufraceCount(shell);
		int triangleCount = 0;
		for (int j = 0; j < surfaceCount; ++j) {
			int surface = brep.getSurface(shell, j);
			const MContainer* mesh = brep.getMesh(shell, j);
			triangleCount += static_cast<int>(mesh->getElementCount(static_cast<kmb::bodyIdType>(surface)));
		}
		output.write(reinterpret_cast<char*>(&triangleCount), sizeof(int));
		for (int j = 0; j < surfaceCount; ++j) {
			kmb::bodyIdType surface = static_cast<kmb::bodyIdType>(brep.getSurface(shell, j));
			const MContainer* mesh = brep.getMesh(shell, j);
			typename MContainer::elementIterator eIter = mesh->beginElementIterator(surface);
			typename MContainer::elementIterator eIterEnd = mesh->endElementIterator(surface);
			while (eIter != eIterEnd) {
				mesh->getNode(eIter[0], p0);
				mesh->getNode(eIter[1], p1);
				mesh->getNode(eIter[2], p2);
				normal = kmb::Point3D::calcNormalVector(p0, p1, p2);
				f[0] = static_cast<float>(normal.x());
				f[1] = static_cast<float>(normal.y());
				f[2] = static_cast<float>(normal.z());
				output.write(reinterpret_cast<char*>(f), 3 * sizeof(float));
				f[0] = static_cast<float>(p0.x());
				f[1] = static_cast<float>(p0.y());
				f[2] = static_cast<float>(p0.z());
				output.write(reinterpret_cast<char*>(f), 3 * sizeof(float));
				f[0] = static_cast<float>(p1.x());
				f[1] = static_cast<float>(p1.y());
				f[2] = static_cast<float>(p1.z());
				output.write(reinterpret_cast<char*>(f), 3 * sizeof(float));
				f[0] = static_cast<float>(p2.x());
				f[1] = static_cast<float>(p2.y());
				f[2] = static_cast<float>(p2.z());
				output.write(reinterpret_cast<char*>(f), 3 * sizeof(float));
				buf[0] = static_cast<char>(i);
				buf[1] = static_cast<char>(j);
				output.write(buf, 2);
				++eIter;
			}
		}
	}
	output.close();
	return 0;
}

template<typename MContainer>
int kmb::StereolithographyIO::saveAsciiPatchBrep(std::string filename, kmb::PatchBrep<MContainer> &brep)
{
	std::cout << "StereolithographyIO saveAsciiPatchBrep" << std::endl;
	std::ofstream output(filename.c_str(), std::ios_base::out);
	if (output.fail()) {
		std::cout << "Save Error : Can't Open File " << filename << "." << std::endl;
		return -1;
	}
	kmb::Point3D p0, p1, p2;
	kmb::Vector3D normal;
	int shellCount = brep.getShellCount();
	for (int i = 0; i < shellCount; ++i) {
		output << "solid patch_" << i << std::endl;
		int shell = brep.getShell(i);
		int surfaceCount = brep.getSufraceCount(shell);
		for (int j = 0; j < surfaceCount; ++j) {
			kmb::bodyIdType surface = static_cast<kmb::bodyIdType>(brep.getSurface(shell, j));
			const MContainer* mesh = brep.getMesh(shell, j);
			typename MContainer::elementIterator eIter = mesh->beginElementIterator(surface);
			typename MContainer::elementIterator eIterEnd = mesh->endElementIterator(surface);
			while (eIter != eIterEnd) {
				if (eIter.getType() == kmb::kTriangle) {
					mesh->getNode(eIter[0], p0);
					mesh->getNode(eIter[1], p1);
					mesh->getNode(eIter[2], p2);
					normal = kmb::Point3D::calcNormalVector(p0, p1, p2);
					output << "  facet normal " << normal.x() << " " << normal.y() << " " << normal.z() << std::endl;
					output << "    outer loop" << std::endl;
					output << "     vertex " << p0.x() << " " << p0.y() << " " << p0.z() << std::endl;
					output << "     vertex " << p1.x() << " " << p1.y() << " " << p1.z() << std::endl;
					output << "     vertex " << p2.x() << " " << p2.y() << " " << p2.z() << std::endl;
					output << "    endloop" << std::endl;
					output << "  endfacet" << std::endl;
				}
				++eIter;
			}
		}
	}
	output.close();
	return 0;
}
